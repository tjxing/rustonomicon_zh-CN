原文链接：<https://doc.rust-lang.org/nomicon/meet-safe-and-unsafe.html>

# 初识安全与非安全代码

大家都希望可以彻底屏蔽代码底层实现的细节。又有谁愿意关心“一个空的元组占用多少内存”这种破事？可惜的是，有时候这些破事却很重要，我们不得不去关注它。开发人员关注实现细节，大部分情况是为了性能优化。但更主要的是，当我们与硬件、操作系统或者其他语言直接打交道的时候，这些细节往往是正确与否的关键。

当使用某种安全编程语言的过程中遇到了处理底层实现的需求时，程序员通常有三种选择：

- 修改代码让编译器或者运行时环境做相关优化
- 采取某些古怪、繁琐的奇技淫巧以实现功能需求
- 使用另一种可以处理底层细节的语言重写代码

对于最后一个选项，程序员通常会选择C语言。某些系统也只对外暴漏了C的接口。

然而，C在使用中往往过于不安全（虽然有时是出于合理的原因）。尤其是在与其他语言交互的过程中，这种不安全性还会被放大。C和与其交互的语言必须时刻小心地确认对方的行为，以防踩到舞伴的脚趾头。

那么这和Rust有什么关系呢？

嗯……不同于C，Rust是一种安全的编程语言。

但是，和C相同的是，Rust是一种非安全的编程语言。

更准确地说，Rust是一种同时包含安全和非安全特性的编程语言。

Rust可以被看作两种编程语言的结合体：安全Rust和非安全Rust。顾名思义，安全Rust是安全的，而不安全Rust……嗯……是不安全的。不安全Rust允许我们做一些非常不安全的事情——就是那些Rust的创造者们求我们别去做可我们偏要做的事情。

安全Rust是一种真正的安全编程语言。如果你所有的代码都是用安全Rust写的，你永远也无需担心类型安全和内存安全，无需费神处理悬垂指针、释放后引用(use-after-free)，或者其他各种未定义的行为。

标准库也提供了相当多的工具，帮助你用符合安全Rust语言规范的方式创建高性能的应用和库。

不过，也许是时候谈论一下另一种语言了。也许你正在写一种标准库没有覆盖到的底层抽象；也许你正在开发标准库（存粹使用Rust语言）；也许你要做一些类型系统不能理解的事情，还要胡乱摆弄各种字节码。也许，你需要非安全Rust了。

非安全Rust和安全Rust的语法规则完全相同，只不过它允许你做一些另外的不安全的行为（下一节再告诉你都包括什么）。

分离安全与非安全Rust的价值在于，我们既可以享受像C那样的非安全语言的好处——也就是对底层实现细节的控制，又不用处理C与其他安全语言集成时遇到的种种问题。

不过还是会遇到一些问题。最明显的。我们必须非常了解类型系统的全部默认要求，并在每次与非安全代码交互的时候检查它们。这也是本书的目的：教给你这些要求以及如何处理它们。